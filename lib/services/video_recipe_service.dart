import 'package:google_generative_ai/google_generative_ai.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter/foundation.dart';
import 'dart:convert';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';

class VideoRecipeService {
  final String? _apiKey;

  VideoRecipeService({String? apiKey}) : _apiKey = apiKey ?? dotenv.env['GEMINI_API_KEY'];

  /// Extract recipe from YouTube URL using Gemini by fetching transcript/metadata
  /// Returns Map with recipe data or null if extraction fails
  Future<Map<String, dynamic>?> extractFromYouTube(String url) async {
    final key = _apiKey;
    if (key == null || key.isEmpty) {
      throw Exception('Gemini API Key is missing. Please check your .env file.');
    }

    // Validate YouTube URL
    if (!_isValidYouTubeUrl(url)) {
      throw Exception('Invalid YouTube URL. Please provide a valid YouTube video link.');
    }

    final yt = YoutubeExplode();
    String videoTitle = '';
    String videoDescription = '';
    String transcriptText = '';

    try {
      debugPrint("üé• Fetching YouTube metadata for: $url");
      
      // 1. Get Video Metadata
      final video = await yt.videos.get(url);
      videoTitle = video.title;
      videoDescription = video.description;
      final videoId = video.id;

      debugPrint("‚úÖ Found Video: $videoTitle");

      // 2. Get Captions/Transcript
      try {
        final manifest = await yt.videos.closedCaptions.getManifest(videoId);
        // Prioritize English, then auto-generated, then anything
        final trackInfo = manifest.getByLanguage('en', autoGenerated: false).firstOrNull 
                       ?? manifest.getByLanguage('en').firstOrNull
                       ?? manifest.tracks.firstOrNull;

        if (trackInfo != null) {
           debugPrint("üìù Downloading transcript (${trackInfo.language.name})...");
           final track = await yt.videos.closedCaptions.get(trackInfo);
           
           // Join captions into a single text block
           transcriptText = track.captions.map((e) => e.text).join(' ');
           debugPrint("‚úÖ Transcript fetched (${transcriptText.length} chars)");
        } else {
           debugPrint("‚ö†Ô∏è No captions found for this video.");
           transcriptText = "[No transcript available]";
        }
      } catch (e) {
        debugPrint("‚ö†Ô∏è Could not fetch captions: $e");
        transcriptText = "[Transcript fetch failed]";
      }

    } catch (e) {
      yt.close();
      throw Exception('Could not fetch video data. Is the link private or invalid? Error: $e');
    } finally {
      yt.close();
    }

    // 3. Analyze with Gemini
    final model = GenerativeModel(
      model: 'gemini-2.5-flash', 
      apiKey: key,
      generationConfig: GenerationConfig(
        responseMimeType: 'application/json',
        temperature: 0.2, 
      ),
    );

    // Truncate huge transcripts if necessary (though Flash context is huge)
    if (transcriptText.length > 50000) {
      transcriptText = transcriptText.substring(0, 50000) + "...[truncated]";
    }

    final prompt = '''
You are an expert chef AI. Extract the FULL recipe from this YouTube video data.

VIDEO TITLE: $videoTitle
VIDEO DESCRIPTION: $videoDescription

TRANSCRIPT/AUDIO CONTENT: 
$transcriptText

INSTRUCTIONS:
1. Analyze the title, description, and transcript to reconstruct the recipe.
2. Ignore irrelevant chatter (sponsors, intro/outro).
3. If the video is NOT a cooking recipe (e.g. gameplay, vlog without cooking), return {"error": "No recipe detected"}.
4. Return ONLY valid JSON matching the schema below.

REQUIRED JSON SCHEMA:
{
  "title": "Exact Recipe Name",
  "description": "Short summary",
  "servings": number or null,
  "prepTime": number or null, 
  "cookTime": number or null,
  "ingredients": ["quantity + item", "e.g. 2 cups flour"],
  "instructions": ["Step 1", "Step 2"],
  "difficulty": "Easy" | "Medium" | "Hard",
  "videoUrl": "$url",
  "videoSource": "youtube"
}

CRITICAL: 
- Ingredients must be a list of strings.
- Instructions must be a list of strings in correct order.
- Timings (prepTime/cookTime) must be numbers (minutes).
''';

    try {
      debugPrint("ü§ñ Sending to Gemini...");
      
      final response = await model.generateContent([Content.text(prompt)]).timeout(
        const Duration(seconds: 60),
        onTimeout: () => throw Exception('AI analysis timed out.'),
      );

      if (response.text == null || response.text!.trim().isEmpty) {
        throw Exception('AI returned empty response.');
      }

      debugPrint("‚úÖ Gemini Response Received");
      
      // Parse JSON response
      final Map<String, dynamic> recipeData = _parseJsonResponse(response.text!);
      
      // Check for explicit error from AI
      if (recipeData.containsKey('error')) {
        throw Exception(recipeData['error']);
      }

      // Validate extracted data
      final validationError = _validateRecipeData(recipeData);
      if (validationError != null) {
        throw Exception(validationError);
      }

      return recipeData;

    } catch (e) {
       debugPrint("‚ùå Extraction Error: $e");
       // Pass through the exception message cleanly
       throw Exception(e.toString().replaceAll('Exception:', '').trim());
    }
  }

  /// Validate YouTube URL format
  bool _isValidYouTubeUrl(String url) {
    if (url.isEmpty) return false;
    final uri = Uri.tryParse(url);
    if (uri == null) return false;
    return uri.host.contains('youtube.com') || uri.host.contains('youtu.be');
  }

  /// Parse JSON response from Gemini
  Map<String, dynamic> _parseJsonResponse(String jsonString) {
    try {
      // Cleanup json markdown if present (though responseMimeType usually handles this)
      jsonString = jsonString
          .replaceAll(RegExp(r'^```json\s*'), '')
          .replaceAll(RegExp(r'^```\s*'), '')
          .replaceAll(RegExp(r'\s*```$'), '')
          .trim();

      final startIndex = jsonString.indexOf('{');
      final endIndex = jsonString.lastIndexOf('}');
      
      if (startIndex == -1 || endIndex == -1) {
         // Try to find any JSON-like structure
         return jsonDecode(jsonString);
      }

      jsonString = jsonString.substring(startIndex, endIndex + 1);
      return jsonDecode(jsonString) as Map<String, dynamic>;
    } catch (e) {
      throw Exception('Failed to parse AI response: $e');
    }
  }

  /// Validate extracted recipe data
  String? _validateRecipeData(Map<String, dynamic> data) {
    if (data['title'] == null || data['title'].toString().isEmpty) {
      return 'Could not detect a recipe title.';
    }
    
    final ingredients = data['ingredients'];
    if (ingredients == null || !(ingredients is List) || ingredients.isEmpty) {
      return 'No ingredients detected. Is this a cooking video?';
    }

    final instructions = data['instructions'];
    if (instructions == null || !(instructions is List) || instructions.isEmpty) {
      return 'No instructions detected.';
    }

    return null;
  }
}
